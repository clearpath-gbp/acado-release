/*
 *    This file is part of ACADO Toolkit.
 *
 *    ACADO Toolkit -- A Toolkit for Automatic Control and Dynamic Optimization.
 *    Copyright (C) 2008-2013 by Boris Houska, Hans Joachim Ferreau,
 *    Milan Vukov, Rien Quirynen, KU Leuven.
 *    Developed within the Optimization in Engineering Center (OPTEC)
 *    under supervision of Moritz Diehl. All rights reserved.
 *
 *    ACADO Toolkit is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation; either
 *    version 3 of the License, or (at your option) any later version.
 *
 *    ACADO Toolkit is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 *
 *    You should have received a copy of the GNU Lesser General Public
 *    License along with ACADO Toolkit; if not, write to the Free Software
 *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */


/**
 *    \file src/utils/acado_utils.cpp
 *    \author Hans Joachim Ferreau, Boris Houska, Milan Vukov
 *    \date 2008 - 2013
 */


#if defined( __WIN32__ ) || defined( WIN32 )

#include <windows.h>
#include <direct.h>

#elif defined( LINUX )

#include <sys/stat.h>
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>

#else

#warning "File I/O is not supported on this platform"

#endif /* defined(__WIN32__) || defined(WIN32) */


#include <acado/utils/acado_utils.hpp>
#include <acado/code_generation/templates/templates.hpp>

#include <iostream>
#include <fstream>

using namespace std;

BEGIN_NAMESPACE_ACADO

#define AUTOGEN_NOTICE_LENGTH 23
static const char* autogenerationNotice[ AUTOGEN_NOTICE_LENGTH ] =
{
		"This file was auto-generated by ACADO Code Generation Tool.\n",
		"\n",
		"ACADO Code Generation tool is a sub-package of ACADO toolkit --\n",
		"A Toolkit for Automatic Control and Dynamic Optimization.\n",
		"Copyright (C) 2008-2013 by Boris Houska, Hans Joachim Ferreau,\n",
		"Milan Vukov, Rien Quirynen, KU Leuven.\n",
		"Developed within the Optimization in Engineering Center (OPTEC)\n",
		"under supervision of Moritz Diehl. All rights reserved.\n",
		"\n",
		"ACADO Toolkit is free software; you can redistribute it and/or\n",
		"modify it under the terms of the GNU Lesser General Public\n",
		"License as published by the Free Software Foundation; either\n",
		"version 3 of the License, or (at your option) any later version.\n",
		"\n",
		"ACADO Toolkit is distributed in the hope that it will be useful,\n",
		"but WITHOUT ANY WARRANTY; without even the implied warranty of\n",
		"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n",
		"Lesser General Public License for more details.\n",
		"\n",
		"You should have received a copy of the GNU Lesser General Public\n",
		"License along with ACADO Toolkit; if not, write to the Free Software\n",
		"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n",
		"\n"
};


/*
 *	p r i n t C o p y r i g h t N o t i c e
 */
returnValue acadoPrintCopyrightNotice(	const char* subpackage
										)
{
	if ( subpackage == 0 )
		return ((returnValue) acadoPrintf(
				"\nACADO Toolkit -- A Toolkit for Automatic Control and Dynamic Optimization.\n" \
				"Copyright (C) 2008-2013 by Boris Houska, Hans Joachim Ferreau,\n" \
				"Milan Vukov, Rien Quirynen, KU Leuven.\n" \
				"Developed within the Optimization in Engineering Center (OPTEC)\n" \
				"under supervision of Moritz Diehl. All rights reserved.\n\n" \
				"ACADO Toolkit is distributed under the terms of the GNU Lesser\n" \
				"General Public License 3 in the hope that it will be useful,\n" \
				"but WITHOUT ANY WARRANTY; without even the implied warranty of\n" \
				"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n" \
				"GNU Lesser General Public License for more details.\n\n" ) );
	else
		return ((returnValue) acadoPrintf(
				"\nACADO Toolkit::%s\n" \
				"Copyright (C) 2008-2013 by Boris Houska, Hans Joachim Ferreau,\n"
				"Milan Vukov, Rien Quirynen, KU Leuven.\n" \
				"Developed within the Optimization in Engineering Center (OPTEC)\n" \
				"under supervision of Moritz Diehl. All rights reserved.\n\n" \
				"ACADO Toolkit is distributed under the terms of the GNU Lesser\n" \
				"General Public License 3 in the hope that it will be useful,\n" \
				"but WITHOUT ANY WARRANTY; without even the implied warranty of\n" \
				"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n" \
				"GNU Lesser General Public License for more details.\n\n", subpackage ));
}


returnValue acadoPrintAutoGenerationNotice(	FILE* file,
											const char* commentString
											)
{
	if (commentString == 0)
	{
		acadoFPrintf(file, "%s", "/*\n");
		for (unsigned i = 0; i < AUTOGEN_NOTICE_LENGTH; ++i)
			acadoFPrintf(file, " *    %s", autogenerationNotice[ i ]);
		acadoFPrintf(file, "%s", " */\n");
	}
	else
	{
		acadoFPrintf(file, "%s\n", commentString);
		for (unsigned i = 0; i < AUTOGEN_NOTICE_LENGTH; ++i)
			acadoFPrintf(file, "%s    %s", commentString, autogenerationNotice[ i ]);
	}

	acadoFPrintf(file,"\n\n");

    return SUCCESSFUL_RETURN;
}



/*
 *	g e t C P U t i m e
 */
double acadoGetTime( )
{
	double current_time = 0.0;

	#if defined(__WIN32__) || defined(WIN32)
	LARGE_INTEGER counter, frequency;
	QueryPerformanceFrequency(&frequency);
	QueryPerformanceCounter(&counter);
	current_time = ((double) counter.QuadPart) / ((double) frequency.QuadPart);
	#elif defined(LINUX)
	struct timeval theclock;
	gettimeofday( &theclock,0 );
	current_time = 1.0*theclock.tv_sec + 1.0e-6*theclock.tv_usec;
	#endif

	return current_time;
}


BooleanType acadoIsInteger( double x )
{
	//if ( fabs( x - floor( x + 0.5) ) < 10000.0*EPS )
	if ( fabs( x - floor( x + 0.5) ) < 1.0e-5 )
		return BT_TRUE;
	else
		return BT_FALSE;
}


double acadoDiv( double nom, double den )
{
	if ( acadoIsInteger( nom/den ) == BT_TRUE )
		return floor( nom/den + 0.5 );
	else
		return floor( nom/den );
}


double acadoMod( double nom, double den )
{
	if ( acadoIsInteger( nom/den ) == BT_TRUE )
		return 0.0;
	else
		return ( nom/den ) - floor( nom/den );
}


int acadoMax( const int x, const int y ){

    return (y<x)?x:y;
}


double acadoMax( const double x, const double y ){

    return (y<x)?x:y;
}


int acadoMin( const int x, const int y ){

    return (y>x)?x:y;
}


double acadoMin( const double x, const double y ){

    return (y>x)?x:y;
}


BooleanType acadoIsEqual( const char* str1, const char* str2 )
{
	if ( ( str1 == 0 ) && ( str2 == 0 ) )
		return BT_TRUE;

	if ( ( str1 == 0 ) && ( str2 != 0 ) )
		return BT_FALSE;

	if ( ( str1 != 0 ) && ( str2 == 0 ) )
		return BT_FALSE;

	if ( strcmp( str1,str2 ) == 0 )
		return BT_TRUE;
	else
		return BT_FALSE;
}


BooleanType acadoIsEqual( double x, double y, double TOL ){

  double maxabs= acadoMax(fabs(x),fabs(y));
	if(maxabs > 1)
	{
		// use relative error
		if ( fabs( x-y )/maxabs >= 10.0*TOL ) return BT_FALSE;
		else                      return BT_TRUE ;
	}
	else
	{
		// use absolute error
		if ( fabs( x-y ) >= 10.0*TOL ) return BT_FALSE;
		else                      return BT_TRUE ;
	}
}


BooleanType acadoIsGreater( double x, double y, double TOL ){

    if ( x >= y - TOL ) return BT_TRUE ;
    else                return BT_FALSE;
}


BooleanType acadoIsSmaller( double x, double y, double TOL ){

    if ( x <= y + TOL ) return BT_TRUE ;
    else                return BT_FALSE;
}


BooleanType acadoIsStrictlyGreater( double x, double y, double TOL ){

    if ( x > y + TOL ) return BT_TRUE ;
    else                return BT_FALSE;
}


BooleanType acadoIsStrictlySmaller( double x, double y, double TOL ){

    if ( x < y - TOL ) return BT_TRUE ;
    else                return BT_FALSE;
}


BooleanType acadoIsPositive( double x, double TOL ){

    if ( x >= TOL ) return BT_TRUE ;
    else            return BT_FALSE;
}


BooleanType acadoIsNegative( double x, double TOL ){

    if ( x <= -TOL ) return BT_TRUE ;
    else             return BT_FALSE;
}


BooleanType acadoIsZero( double x, double TOL ){

    return acadoIsEqual( x, 0.0, TOL );
}


BooleanType acadoIsInfty( double x, double TOL )
{
	if ( ( acadoIsGreater( x, INFTY, TOL ) == BT_TRUE ) ||
		 ( acadoIsSmaller( x,-INFTY, TOL ) == BT_TRUE ) )
		return BT_TRUE;
	else
		return BT_FALSE;
}


BooleanType acadoIsFinite( double x, double TOL )
{
	if ( ( acadoIsStrictlySmaller( x, INFTY, TOL ) == BT_TRUE ) &&
		 ( acadoIsStrictlyGreater( x,-INFTY, TOL ) == BT_TRUE ) )
		return BT_TRUE;
	else
		return BT_FALSE;
}


BooleanType acadoIsNaN(	double x
						)
{
	if ( ( x > -1.0 ) || ( x < 1.0 ) )
		return BT_FALSE;
	else
		return BT_TRUE;
}



int acadoRound (double x){

	if (x - floor(x) > 0.5)
		return (int)ceil(x);
	else
		return (int)floor(x);

}


int acadoFactorial( int n ){
  
	ASSERT( n>= 0 );
	int r = 1;
	for (int i = n; i > 1; --i)
		r *= i;
	return r;
}


int acadoRoundAway (double x) {

	return x < 0 ? floor(x) : ceil(x);
}


returnValue acadoAssignString(	char** toString,
								const char* const fromString,
								const char* const defaultString
								)
{
	if ( *toString == 0 )
		*toString = new char[MAX_LENGTH_NAME+1];

	if ( fromString != 0 )
	{
		for( uint i=0; i<=MAX_LENGTH_NAME; ++i )
		{
			(*toString)[i] = fromString[i];

			if ( fromString[i] == '\0' )
				break;
		}
	}
	else
	{
		/* if fromString is empty, use defaultString */
		if ( defaultString != 0 )
		{
			for( uint i=0; i<=MAX_LENGTH_NAME; ++i )
			{
				(*toString)[i] = defaultString[i];

				if ( defaultString[i] == '\0' )
					break;
			}
		}
		else
			return ACADOERROR( RET_UNKNOWN_BUG );
	}

	return SUCCESSFUL_RETURN;
}

returnValue acadoCopyFile(	const char* source,
							const char* destination,
							const char* commentString,
							BooleanType printCodegenNotice
							)
{
	std::ifstream  src( source );
	if (src.is_open() == false)
	{
		LOG( LVL_ERROR ) << "Could not open the source file: " << source << std::endl;
		return ACADOERROR( RET_INVALID_ARGUMENTS );
	}

	std::ofstream  dst( destination );
	if (dst.is_open() == false)
	{
		LOG( LVL_ERROR ) << "Could not open the destination file: " << destination << std::endl;
		return ACADOERROR( RET_INVALID_ARGUMENTS );
	}

	if (printCodegenNotice == BT_TRUE)
	{
		if (commentString == 0)
		{
			dst << "/*" << endl;
			for (unsigned i = 0; i < AUTOGEN_NOTICE_LENGTH; ++i)
				dst << " *    " << autogenerationNotice[ i ];
			dst << " */" << endl << endl;
		}
		else
		{
			dst << commentString << endl;
			for (unsigned i = 0; i < AUTOGEN_NOTICE_LENGTH; ++i)
				dst << commentString << "    " << autogenerationNotice[ i ];
			dst << endl;
		}
	}

	dst << src.rdbuf();

	return SUCCESSFUL_RETURN;
}

returnValue acadoCopyTempateFile(	const char* source,
									const char* destination,
									const char* commentString,
									BooleanType printCodegenNotice
									)
{
	const string folders( TEMPLATE_PATHS );
	ifstream inputFile;
	size_t oldPos = 0;

	while( 1 )
	{
		size_t pos;
		string tmp;

		pos = folders.find(";", oldPos);
		tmp = folders.substr(oldPos, pos) + "/" + source;

		inputFile.open(tmp.c_str());

		if (inputFile.is_open() == true)
			return acadoCopyFile(tmp.c_str(), destination, commentString, printCodegenNotice);

		if (pos == string::npos)
			break;

		oldPos = pos + 1;
	}

	LOG( LVL_ERROR ) << "Could not open the template file: " << source << std::endl;
	return ACADOERROR( RET_INVALID_ARGUMENTS );
}

returnValue acadoCreateFolder(const char* name)
{
#if defined( __WIN32__ ) || defined( WIN32 )

	if ( _mkdir( name) )
	{
		// TODO give here an error code
		LOG( LVL_ERROR ) << "Problem creating directory " << name << endl;
		return ACADOERROR( RET_INVALID_ARGUMENTS );
	}

#elif defined( LINUX )

	struct stat st = {0};

	if (stat(name, &st) == -1)
	{
	    if (mkdir(name, 0700) == -1)
	    {
	    	// TODO give here an error code
	    	LOG( LVL_ERROR ) << "Problem creating directory " << name << endl;
	    	return ACADOERROR( RET_INVALID_ARGUMENTS );
	    }
	}

#else

	return ACADOERRORTEXT(RET_INVALID_OPTION, "Unsupported platform.");

#endif /* defined(__WIN32__) || defined(WIN32) */

	return SUCCESSFUL_RETURN;
}

CLOSE_NAMESPACE_ACADO


/*
 *	end of file
 */
